% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/narrate_forecast.R
\name{narrate_forecast}
\alias{narrate_forecast}
\title{Create Narrative for Time Series Forecast Data Frames}
\usage{
narrate_forecast(
  df,
  date = NULL,
  frequency = NULL,
  summarization = "sum",
  type = "yoy",
  coverage = 0.5,
  coverage_limit = 5,
  narration_depth = 2,
  use_chatgpt = FALSE,
  openai_api_key = Sys.getenv("OPENAI_API_KEY"),
  max_tokens = 1024,
  temperature = 0,
  top_p = 1,
  frequency_penalty = 0,
  presence_penalty = 0,
  forecast = "Forecast",
  actuals = "Actuals",
  template_cy =
    "Forecasted volumes for {current_year} are equal to {format_num(cy_forecast)}.",
  template_ftm = "Overall forecast for the next 12 months is {format_num(ftm_forecast)}.",
  template_ftm_change =
    "Projected {trend} in the next 12 months is equal to {format_num(ftm_change)} ({ftm_change_p}\%).",
  use_renviron = FALSE,
  return_data = FALSE,
  simplify = FALSE,
  format_numbers = TRUE,
  collapse_sep = ", ",
  collapse_last = " and ",
  ...
)
}
\arguments{
\item{df}{\code{\link[=data.frame]{data.frame()}} or \code{\link[=tibble]{tibble()}} Data frame of tibble, can be aggregated or raw}

\item{date}{Name of the date column to be used for time based analysis}

\item{frequency}{Level of time based aggregation for comparing across years 'quarter', 'month', 'week'}

\item{summarization}{Approach for data summarization/aggregation - 'sum', 'count' or 'average'}

\item{type}{Type of trend analysis to create: 1 or 'yoy', 2 or 'previous period', 3 or 'same period last year'}

\item{coverage}{Numeric portion of variability to be covered by narrative, 0 to 1}

\item{coverage_limit}{Integer maximum number of elements to be narrated, overrides
coverage to avoid extremely verbose narrative creation}

\item{narration_depth}{Parameter to control the depth of the analysis 1 for summary and 2 for detailed}

\item{use_chatgpt}{If \link{TRUE} - use ChatGPT to enhance the narrative}

\item{openai_api_key}{Your OpenAI API key, you can set it up in .Renviron file as "OPENAI_API_KEY", function will look for it with \code{Sys.getenv("OPENAI_API_KEY")}}

\item{max_tokens}{The maximum number of tokens to generate in the chat completion.}

\item{temperature}{What sampling temperature to use, between 0 and 2. Higher
values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.}

\item{top_p}{An alternative to sampling with temperature, called nucleus sampling, where the model considers
the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10\% probability mass are considered.}

\item{frequency_penalty}{Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far,
decreasing the model's likelihood to repeat the same line verbatim.}

\item{presence_penalty}{Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far,
increasing the model's likelihood to talk about new topics.}

\item{forecast}{Name of the forecast column in the data frame}

\item{actuals}{Name of the actuals column in the data frame}

\item{template_cy}{\code{\link[glue]{glue}} template for current year volumes narrative}

\item{template_ftm}{\code{\link[glue]{glue}} template for future 12 months projection}

\item{template_ftm_change}{\code{\link[glue]{glue}} template for projected change in the next 12 months}

\item{use_renviron}{If \link{TRUE} use .Renviron variables in the template.
You can also set \code{options(narrator.use_renviron = TRUE)} to make it global for the session,
or create an environment variable "use_renviron" by changing your .Renviron file \code{usethis::edit_r_environ()}}

\item{return_data}{If \link{TRUE} - return a list of variables used in the function's templates}

\item{simplify}{If \link{TRUE} - return a character vector, if \link{FALSE} - named list}

\item{format_numbers}{If \link{TRUE} - format big numbers to K/M/B using \code{\link[=format_num]{format_num()}} function}

\item{collapse_sep}{Separator for \code{\link[glue]{glue_collapse}} in cases with multiple values in single variable}

\item{collapse_last}{Separator for \code{\link[glue]{glue_collapse}} for the last item, in cases with multiple values in single variable}

\item{...}{other arguments passed to \code{\link[glue]{glue}}}
}
\value{
A \code{\link[=list]{list()}} of narratives by default and \code{\link[=character]{character()}} if \code{simplify = TRUE}
}
\description{
Create Narrative for Time Series Forecast Data Frames
}
\examples{
\dontshow{if (rlang::is_installed("prophet")) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
library(prophet)
library(dplyr)
library(tidyr)

fit_prophet <- function(data) {
  model <- prophet(data)
  future <- make_future_dataframe(model, periods = 12, freq = "month")
  forecast <- predict(model, future)
  return(forecast)
}
grouped_data <- sales \%>\%
  dplyr::mutate(ds = lubridate::floor_date(Date, unit = "month")) \%>\%
  dplyr::group_by(Region, ds) \%>\%
  dplyr::summarise(y = sum(Sales, na.rm = TRUE)) \%>\%
  tidyr::nest()

grouped_data$forecast <- lapply(grouped_data$data, fit_prophet)

actuals <- grouped_data \%>\%
  dplyr::select(-forecast) \%>\%
  unnest(data)

df <- grouped_data \%>\%
  dplyr::select(-data) \%>\%
  unnest(forecast) \%>\%
  dplyr::select(ds, yhat) \%>\%
  dplyr::left_join(actuals) \%>\%
  dplyr::rename(Actuals = y,
                Forecast = yhat)

narrate_forecast(df)
\dontshow{\}) # examplesIf}
}
