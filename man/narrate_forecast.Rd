% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/narrate_forecast.R
\name{narrate_forecast}
\alias{narrate_forecast}
\title{Create Narrative for Time Series Forecast Data Frames}
\usage{
narrate_forecast(
  df,
  measure = NULL,
  dimensions = NULL,
  date = NULL,
  frequency = NULL,
  summarization = "sum",
  type = "yoy",
  coverage = 0.5,
  coverage_limit = 5,
  narration_depth = 2,
  use_chatgpt = FALSE,
  openai_api_key = Sys.getenv("OPENAI_API_KEY"),
  forecast = "Forecast",
  actuals = "Actuals",
  template_cy = "Forecasted volume for {current_year} is {format_num(cy_forecast)}",
  template_ftm = "Overall forecast for the next 12 months is {format_num(ftm_forecast)}",
  template_ftm_change =
    "Projected {trend} in the next 12 months is equal to {format_num(ftm_change)} ({ftm_change_p}\%).",
  use_renviron = FALSE,
  return_data = FALSE,
  simplify = FALSE,
  format_numbers = TRUE,
  collapse_sep = ", ",
  collapse_last = " and ",
  ...
)
}
\arguments{
\item{df}{\code{\link[=data.frame]{data.frame()}} or \code{\link[=tibble]{tibble()}} Data frame of tibble, can be aggregated or raw}

\item{measure}{Numeric measure for function to create calculations with,
if NULL then it will take the first numeric field available}

\item{dimensions}{Vector of dimensions for analysis, by default all character
or factor variable will be used}

\item{date}{Name of the date column to be used for time based analysis}

\item{frequency}{Level of time based aggregation for comparing across years}

\item{summarization}{Approach for data summarization/aggregation - 'sum', 'count' or 'average'}

\item{type}{Type of trend analysis to create: 1 or 'yoy', 2 or 'previous period', 3 or 'same period last year'}

\item{coverage}{Numeric portion of variability to be covered by narrative, 0 to 1}

\item{coverage_limit}{Integer maximum number of elements to be narrated, overrides
coverage to avoid extremely verbose narrative creation}

\item{narration_depth}{Parameter to control the depth of the analysis 1 for summary and 2 for detailed}

\item{use_chatgpt}{If \link{TRUE} - use ChatGPT to enhance the narrative}

\item{openai_api_key}{Your OpenAI API key, you can set it up in .Renviron file as "OPENAI_API_KEY", function will look for it with \code{Sys.getenv("OPENAI_API_KEY")}}

\item{forecast}{Name of the forecast column in the data frame}

\item{actuals}{Name of the actuals column in the data frame}

\item{use_renviron}{If \link{TRUE} use .Renviron variables in the template.
You can also set \code{options(narrator.use_renviron = TRUE)} to make it global for the session,
or create an environment variable "use_renviron" by changing your .Renviron file \code{usethis::edit_r_environ()}}

\item{return_data}{If \link{TRUE} - return a list of variables used in the function's templates}

\item{simplify}{If \link{TRUE} - return a character vector, if \link{FALSE} - named list}

\item{format_numbers}{If \link{TRUE} - format big numbers to K/M/B using \code{\link[=format_num]{format_num()}} function}

\item{collapse_sep}{Separator for \code{\link[glue]{glue_collapse}} in cases with multiple values in single variable}

\item{collapse_last}{Separator for \code{\link[glue]{glue_collapse}} for the last item, in cases with multiple values in single variable}

\item{...}{other arguments passed to \code{\link[glue]{glue}}}
}
\value{
A \code{\link[=list]{list()}} of narratives by default and \code{\link[=character]{character()}} if \code{simplify = TRUE}
}
\description{
Create Narrative for Time Series Forecast Data Frames
}
\examples{
library(prophet)
library(dplyr)
library(tidyr)

fit_prophet <- function(data) {
  model <- prophet(data)
  future <- make_future_dataframe(model, periods = 12, freq = "month")
  forecast <- predict(model, future)
  return(forecast)
}
grouped_data <- sales \%>\%
  dplyr::mutate(ds = lubridate::floor_date(Date, unit = "month")) \%>\%
  dplyr::group_by(Region, ds) \%>\%
  dplyr::summarise(y = sum(Sales, na.rm = TRUE)) \%>\%
  tidyr::nest()

grouped_data$forecast <- lapply(grouped_data$data, fit_prophet)

actuals <- grouped_data \%>\%
  dplyr::select(-forecast) \%>\%
  unnest(data)

df <- grouped_data \%>\%
  dplyr::select(-data) \%>\%
  unnest(forecast) \%>\%
  dplyr::select(ds, yhat) \%>\%
  dplyr::left_join(actuals) \%>\%
  dplyr::rename(Actuals = y,
                Forecast = yhat)

narrate_forecast(df)
}
